# `game-core/spells/TagSystem.ts`

## 1. Purpose

The `TagSystem.ts` module is designed to manage and process "tags" associated with spells or other game entities. Its primary purpose is to calculate an array of "effective tags" by resolving conflicts between tags based on a predefined order of precedence. This ensures that when a spell has multiple tags with potentially contradictory effects, a deterministic and balanced outcome is achieved. The module also provides utility functions for retrieving tag definitions, checking for direct conflicts between two tags, and querying the precedence level of a tag.

## 2. Functionality

The module offers the following key functionalities:

*   **Effective Tag Calculation:** Takes an array of tags assigned to a spell and returns a new array of tags that are considered "effective" after resolving any conflicts according to the defined `tagPrecedenceList`.
*   **Conflict Resolution:** When two tags conflict, the tag with higher precedence (a lower index in `tagPrecedenceList`) is kept, and the other is discarded.
*   **Tag Definition Retrieval:** Allows fetching the full definition of a tag (which includes properties like what other tags it conflicts with).
*   **Direct Conflict Checking:** Provides a way to check if two specific tags are defined as conflicting with each other.
*   **Precedence Querying:** Allows querying the precedence index of a specific tag.

## 3. File Contents

The file includes a key constant for defining precedence, several exported utility functions, and relies on an external constant for tag definitions.

### Constants

*   **`tagPrecedenceList: TagName[]`**:
    *   This array is crucial for the conflict resolution logic. It is generated by taking all the keys (tag names) from the `TAG_DEFINITIONS` constant.
    *   **Important:** The order of tags in this list dictates their precedence. Tags appearing earlier in the `tagPrecedenceList` (i.e., having a lower index) take precedence over tags appearing later. The current generation method means precedence is implicitly defined by the order of keys in the `TAG_DEFINITIONS` object.

### External Dependencies

*   **`TAG_DEFINITIONS` (from `../../constants`)**:
    *   This is a critical external data structure, expected to be an object where keys are `TagName`s and values are `TagDefinition` objects. Each `TagDefinition` should specify properties of the tag, most importantly an optional `conflictsWith: TagName[]` array listing other tags it directly conflicts with.

### Exported Functions

*   `getEffectiveTags(spellTags: TagName[] | undefined): TagName[]`: The main function for calculating effective tags after conflict resolution.
*   `getTagDefinition(tagName: TagName): TagDefinition | undefined`: Retrieves the definition for a given `tagName` from `TAG_DEFINITIONS`.
*   `doTagsConflict(tag1: TagName, tag2: TagName): boolean`: Checks if two tags are defined to conflict with each other.
*   `getTagPrecedence(tagName: TagName): number`: Returns the precedence index of a tag from `tagPrecedenceList`.

## 4. Types and Interfaces (Detailed)

### `TagName`
*   This is an imported type (from `../../types`). It is expected to be a string literal union type representing all valid and recognized tag names in the game system (e.g., `'Fire'`, `'Ice'`, `'Healing'`, `'AoE'`, `'SingleTarget'`).
    ```typescript
    // Example (expected structure in ../../types)
    // export type TagName =
    //   | 'Fire'
    //   | 'Ice'
    //   | 'Lightning'
    //   | 'Healing'
    //   | 'Buff'
    //   | 'Debuff'
    //   // ... and so on for all possible tags
    ```

### `TagDefinition`
*   This is an imported type (from `../../types`). It defines the structure for the information associated with each `TagName`.
    ```typescript
    // Example (expected structure in ../../types)
    // export interface TagDefinition {
    //   name: string; // User-friendly name, often same as TagName
    //   description: string; // What this tag generally implies
    //   conflictsWith?: TagName[]; // Optional array of other TagNames this tag conflicts with
    //   // ... other potential properties like 'enhances?: TagName[]', 'category?: string', etc.
    // }
    ```
*   The `conflictsWith` property is vital for the `TagSystem` to function correctly.

## 5. `getEffectiveTags` Function Logic

The `getEffectiveTags` function is the core of this module. Its logic for resolving conflicts is as follows:

1.  **Initialization:**
    *   If the input `spellTags` is empty or undefined, it returns an empty array.
    *   Initializes an empty `effectiveTags` array (though its direct use for populating the final result is less clear in the provided code, `tagsToRemove` is the primary driver).
    *   Initializes a `tagsToRemove = new Set<TagName>()` to keep track of tags that lose precedence conflicts.

2.  **Conflict Identification Pass:**
    *   It iterates through each `tagName` in the input `spellTags`.
    *   If `tagName` is already in `tagsToRemove`, it's skipped.
    *   It fetches the `tagDef` from `TAG_DEFINITIONS`. If not found, a warning is logged, and the tag is provisionally kept.
    *   If `tagDef.conflictsWith` exists, it iterates through each `conflictingTagName` listed there.
        *   It checks if this `conflictingTagName` is also present in the original `spellTags`.
        *   If both conflicting tags are present, their precedence is compared using their indices in `tagPrecedenceList`:
            *   If `tagName` has a lower index (higher precedence) than `conflictingTagName`, `conflictingTagName` is added to `tagsToRemove`. A warning is logged.
            *   If `conflictingTagName` has a lower index (higher precedence) than `tagName`, `tagName` is added to `tagsToRemove`. A warning is logged, and the inner loop for `tagName`'s conflicts breaks (since `tagName` itself is being removed).
            *   If indices are equal or one is not found in `tagPrecedenceList`, a warning is logged, and a default behavior attempts to resolve (generally favoring the "known" tag if one is unknown to the precedence list).

3.  **Constructing Final List:**
    *   The function then filters the original `spellTags` array, keeping only those tags that are *not* present in the `tagsToRemove` set. This automatically preserves the original order of the non-conflicting tags.
    *   `const trulyEffectiveTags = spellTags.filter(tag => !tagsToRemove.has(tag));` is the effective line that produces the final result.
    *   A console warning is issued if the length of the original tags array differs from the effective tags array, showing both lists for debugging.

4.  **Return Value:** Returns the `trulyEffectiveTags` array.

## 6. Refactoring Guide & Potential Improvements

The `TagSystem.ts` module is crucial for game balance and ensuring spell effects are predictable.

1.  **Explicit `tagPrecedenceList` Definition:**
    *   **Current:** `tagPrecedenceList` is implicitly defined by `Object.keys(TAG_DEFINITIONS)`. This means the order of declaration of tags in the `TAG_DEFINITIONS` object dictates global precedence.
    *   **Suggestion:** For critical systems like tag precedence, it's often safer and clearer to manually define the `tagPrecedenceList` in an explicit, curated order. This makes precedence independent of object key ordering (which can sometimes have subtle variations across JavaScript environments, though typically stable now) and makes the intended precedence hierarchy immediately obvious to developers.
        ```typescript
        // Example of explicit definition
        // export const tagPrecedenceList: TagName[] = [
        //   'AbsoluteBuff', // Highest precedence
        //   'SingleTarget',
        //   'AoE',          // Conflicts with SingleTarget, SingleTarget wins if both present
        //   'Fire',
        //   'Ice',          // Fire might win over Ice if they conflict and Fire is earlier
        //   // ... other tags in desired order
        // ];
        ```

2.  **Clarity of `getEffectiveTags` Logic:**
    *   The current `getEffectiveTags` function uses multiple loops and conditional checks. While it aims for correctness, its complexity can make it hard to follow.
    *   **Suggestion:** Consider if the logic can be simplified or broken down further. For instance, one could first build a map of tags to their precedence, then iterate. However, the current approach of using a `Set` for `tagsToRemove` and then filtering the original list is quite efficient. The main improvement would be ensuring the precedence list itself is explicitly and clearly defined.
    *   The section with `effectiveTags.push(tagName)` inside the loop, and then later `finalEffectiveTags` and `trulyEffectiveTags` can be a bit confusing. The single filter `spellTags.filter(tag => !tagsToRemove.has(tag))` is the most direct way to get the result while preserving order. The code seems to converge on this, but the intermediate `effectiveTags.push` could be removed if not essential for a specific edge case not immediately apparent.

3.  **Handling of Undefined Tags or Precedence:**
    *   If a tag is in `spellTags` but not in `TAG_DEFINITIONS` or `tagPrecedenceList`, warnings are logged. The behavior is to generally keep such tags unless a defined tag conflicts with and removes them.
    *   **Consideration:** Decide if this is the desired outcome. Alternatively, unknown tags could be stripped by default, or cause an error, depending on how strict the system needs to be.

4.  **Symmetry in `conflictsWith`:**
    *   The `doTagsConflict` function correctly checks for conflicts in both directions (`tag1.conflictsWith.includes(tag2)` OR `tag2.conflictsWith.includes(tag1)`).
    *   **Recommendation:** Enforce by convention or tooling that if TagA conflicts with TagB, TagB's definition should also list TagA in its `conflictsWith`. This makes the `TAG_DEFINITIONS` data more robust and easier to reason about.

5.  **Performance:**
    *   For a typical number of spell tags (e.g., 3-7), the current performance of `getEffectiveTags` should be perfectly adequate. If spells could have a very large number of tags (e.g., 20+), and this function is called extremely frequently in performance-critical loops, then a more optimized algorithm might be considered. However, this is likely a premature optimization for most game designs.

6.  **Console Warnings:**
    *   The `console.warn` calls are very helpful during development and for debugging `TAG_DEFINITIONS`.
    *   **Consideration:** For a production build, these warnings might become noisy if minor data inconsistencies exist. It might be useful to have these warnings conditional on a development/debug mode flag.

The robustness of the `TagSystem` is highly dependent on the accuracy and completeness of the `TAG_DEFINITIONS` constant, particularly the `conflictsWith` arrays and the order implied or explicitly defined in `tagPrecedenceList`. Clear documentation and careful management of these data structures are key.
